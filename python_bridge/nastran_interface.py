"""
NASTRAN Interface Module
========================
Complete NASTRAN integration for panel flutter analysis.
Generates validated BDF files and parses F06 results.
"""

import numpy as np
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
import re
import logging


class NastranBDFGenerator:
    """
    Generates validated NASTRAN BDF files for flutter analysis (SOL 145)
    Following MSC NASTRAN Quick Reference Guide
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.card_width = 8  # Field width for NASTRAN cards
    
    def generate_flutter_bdf(self, panel: 'PanelProperties', flow: 'FlowConditions',
                            mesh_nx: int = 20, mesh_ny: int = 20,
                            n_modes: int = 20, v_range: Tuple[float, float] = (100, 2000),
                            output_path: Optional[Path] = None) -> str:
        """
        Generate complete NASTRAN BDF file for flutter analysis
        
        Args:
            panel: Panel structural properties
            flow: Flow conditions
            mesh_nx, mesh_ny: Structural mesh density
            n_modes: Number of modes for modal analysis
            v_range: Velocity range for flutter analysis (m/s)
            output_path: Optional path to save BDF file
        
        Returns:
            Complete BDF file content as string
        """
        
        self.logger.info(f"Generating NASTRAN BDF for {mesh_nx}x{mesh_ny} mesh, {n_modes} modes")
        
        # Build BDF sections
        sections = [
            self._generate_header(panel, flow),
            self._generate_executive_control(n_modes),
            self._generate_case_control(),
            "BEGIN BULK",
            self._generate_parameters(),
            self._generate_materials(panel),
            self._generate_properties(panel),
            self._generate_grid_points(panel, mesh_nx, mesh_ny),
            self._generate_elements(mesh_nx, mesh_ny),
            self._generate_constraints(panel.boundary_conditions, mesh_nx, mesh_ny),
            self._generate_aero_cards(flow),
            self._generate_aerodynamic_mesh(panel, flow, mesh_nx, mesh_ny),
            self._generate_splines(mesh_nx, mesh_ny),
            self._generate_flutter_cards(flow, v_range, n_modes),
            self._generate_eigenvalue_cards(n_modes),
            "ENDDATA"
        ]
        
        bdf_content = "\n".join(sections)
        
        # Validate BDF
        validation_errors = self._validate_bdf(bdf_content)
        if validation_errors:
            self.logger.warning(f"BDF validation warnings: {validation_errors}")
        
        # Save if path provided
        if output_path:
            with open(output_path, 'w') as f:
                f.write(bdf_content)
            self.logger.info(f"BDF file saved to {output_path}")
        
        return bdf_content
    
    def _generate_header(self, panel, flow) -> str:
        """Generate BDF header with problem description"""
        return f"""$ NASTRAN PANEL FLUTTER ANALYSIS
$ Generated by Flutter Analysis System
$ Panel: {panel.length*1000:.1f}mm x {panel.width*1000:.1f}mm x {panel.thickness*1000:.1f}mm
$ Material: E={panel.youngs_modulus/1e9:.1f}GPa, nu={panel.poissons_ratio:.2f}, rho={panel.density:.0f}kg/m3
$ Flow: Mach={flow.mach_number:.2f}, Alt={flow.altitude:.0f}m
$ Boundary Conditions: {panel.boundary_conditions}
$"""
    
    def _generate_executive_control(self, n_modes: int) -> str:
        """Generate Executive Control Section"""
        return f"""SOL 145         $ Flutter Analysis
CEND
ECHO = NONE
MAXLINES = 999999999"""
    
    def _generate_case_control(self) -> str:
        """Generate Case Control Section"""
        return """TITLE = Panel Flutter Analysis
SUBTITLE = Physics-Based Flutter Prediction
LABEL = Validated Analysis
METHOD = 1      $ Eigenvalue extraction method
FMETHOD = 1     $ Flutter method
SPC = 1         $ Single point constraints
DISP = ALL      $ Output displacements
SPCF = ALL      $ Output SPC forces
STRESS = ALL    $ Output stresses
STRAIN = ALL    $ Output strains
FORCE = ALL     $ Output forces
AEROF = ALL     $ Output aerodynamic forces
APRES = ALL     $ Output aerodynamic pressures
TRIM = 1        $ Trim condition
DIVERG = 1      $ Divergence analysis"""
    
    def _generate_parameters(self) -> str:
        """Generate parameter cards"""
        return """$ PARAMETERS
PARAM   GRDPNT  0       $ Reference grid point
PARAM   AUTOSPC YES     $ Automatic constraint elimination
PARAM   COUPMASS1       $ Coupled mass matrix
PARAM   WTMASS  .00259  $ Weight-to-mass conversion
PARAM   AUNITS  1.0     $ Acceleration units
PARAM   VREF    1000.0  $ Reference velocity
PARAM   POST    -1      $ Post-processing flag
PARAM   PRTMAXIM YES    $ Print maximum values"""
    
    def _generate_materials(self, panel) -> str:
        """Generate material cards"""
        mat_id = 1
        return f"""$ MATERIALS
$       MID     E       G       NU      RHO
MAT1    {mat_id:<8}{self._format_sci(panel.youngs_modulus):<8}{' '*8}{panel.poissons_ratio:<8.4f}{self._format_sci(panel.density):<8}"""
    
    def _generate_properties(self, panel) -> str:
        """Generate property cards"""
        prop_id = 1
        mat_id = 1
        return f"""$ PROPERTIES
$       PID     MID     T
PSHELL  {prop_id:<8}{mat_id:<8}{panel.thickness:<8.5f}"""
    
    def _generate_grid_points(self, panel, nx: int, ny: int) -> str:
        """Generate grid points for structural mesh"""
        lines = ["$ GRID POINTS"]
        lines.append("$       GID     CP      X       Y       Z")
        
        gid = 1
        dx = panel.length / nx
        dy = panel.width / ny
        
        for i in range(nx + 1):
            for j in range(ny + 1):
                x = i * dx
                y = j * dy
                z = 0.0
                lines.append(f"GRID    {gid:<8}{0:<8}{x:<8.5f}{y:<8.5f}{z:<8.5f}")
                gid += 1
        
        return "\n".join(lines)
    
    def _generate_elements(self, nx: int, ny: int) -> str:
        """Generate CQUAD4 elements"""
        lines = ["$ ELEMENTS"]
        lines.append("$       EID     PID     G1      G2      G3      G4")
        
        eid = 1
        pid = 1
        
        for i in range(nx):
            for j in range(ny):
                # Grid point numbering
                g1 = i * (ny + 1) + j + 1
                g2 = (i + 1) * (ny + 1) + j + 1
                g3 = (i + 1) * (ny + 1) + j + 2
                g4 = i * (ny + 1) + j + 2
                
                lines.append(f"CQUAD4  {eid:<8}{pid:<8}{g1:<8}{g2:<8}{g3:<8}{g4:<8}")
                eid += 1
        
        return "\n".join(lines)
    
    def _generate_constraints(self, bc_type: str, nx: int, ny: int) -> str:
        """Generate Single Point Constraints based on boundary conditions"""
        lines = ["$ SINGLE POINT CONSTRAINTS"]
        spc_id = 1
        
        # Parse boundary condition string (e.g., 'SSSS', 'CCCC', 'CFFF')
        # S = Simply Supported, C = Clamped, F = Free
        bc_edges = list(bc_type) if len(bc_type) == 4 else ['S', 'S', 'S', 'S']
        
        # Define DOF constraints for each BC type
        dof_map = {
            'S': '3',      # Simply supported: constrain Z translation
            'C': '123456', # Clamped: constrain all DOFs
            'F': ''        # Free: no constraints
        }
        
        constrained_nodes = set()
        
        # Edge 1: x=0 (j varies)
        if bc_edges[0] != 'F':
            for j in range(ny + 1):
                gid = j + 1
                constrained_nodes.add(gid)
        
        # Edge 2: x=L (j varies)
        if bc_edges[1] != 'F':
            for j in range(ny + 1):
                gid = nx * (ny + 1) + j + 1
                constrained_nodes.add(gid)
        
        # Edge 3: y=0 (i varies)
        if bc_edges[2] != 'F':
            for i in range(nx + 1):
                gid = i * (ny + 1) + 1
                constrained_nodes.add(gid)
        
        # Edge 4: y=W (i varies)
        if bc_edges[3] != 'F':
            for i in range(nx + 1):
                gid = i * (ny + 1) + ny + 1
                constrained_nodes.add(gid)
        
        # Generate SPC cards
        if constrained_nodes:
            # Use SPC1 card for efficiency
            dof = dof_map.get(bc_edges[0], '3')  # Use first edge BC type
            node_list = sorted(constrained_nodes)
            
            lines.append(f"SPC1    {spc_id:<8}{dof:<8}", end="")
            
            # Add nodes in groups of 8
            for i, node in enumerate(node_list):
                if i % 8 == 0 and i > 0:
                    lines.append("")
                    lines.append(f"+       {node:<8}", end="")
                else:
                    lines.append(f"{node:<8}", end="")
        
        return "\n".join(lines)
    
    def _generate_aero_cards(self, flow) -> str:
        """Generate aerodynamic reference cards"""
        # Calculate reference values
        ref_chord = 1.0  # Reference chord
        ref_span = 1.0   # Reference span
        ref_area = ref_chord * ref_span
        
        # Symmetry flags (0 = no symmetry)
        symxz = 0
        symxy = 0
        
        return f"""$ AERODYNAMIC CARDS
$       ACSID   VEL     REFC    RHOREF  SYMXZ   SYMXY
AERO    0       {flow.velocity:<8.2f}{ref_chord:<8.4f}{flow.density:<8.5f}{symxz:<8}{symxy:<8}
$
$       ACSID   XREF    YREF    ZREF    SREF
AEROS   0       0.0     0.0     0.0     {ref_area:<8.4f}"""
    
    def _generate_aerodynamic_mesh(self, panel, flow, nx: int, ny: int) -> str:
        """Generate aerodynamic panels (CAERO cards)"""
        lines = ["$ AERODYNAMIC PANELS"]
        
        # Determine element type based on Mach number
        if flow.mach_number > 1.2:
            # Use CAERO5 for supersonic (Piston Theory)
            lines.extend(self._generate_caero5(panel, nx, ny))
        else:
            # Use CAERO1 for subsonic (Doublet Lattice)
            lines.extend(self._generate_caero1(panel, nx, ny))
        
        return "\n".join(lines)
    
    def _generate_caero5(self, panel, nx: int, ny: int) -> List[str]:
        """Generate CAERO5 cards for Piston Theory"""
        lines = []
        caero_id = 1001
        
        # CAERO5 card format
        lines.append("$ CAERO5 - Piston Theory Panels")
        lines.append(f"$       EID     PID     CP      NSPAN   NCHORD  LSPAN   LCHORD")
        
        # Single macro-element for piston theory
        pid = 2001  # PAERO5 ID
        cp = 0      # Coordinate system
        nspan = ny  # Number of spanwise strips
        nchord = nx # Number of chordwise strips
        
        # Calculate corner points
        x1, y1, z1 = 0.0, 0.0, 0.001  # Small offset in Z
        x2, y2 = panel.length, 0.0
        x3, y3 = panel.length, panel.width
        x4, y4 = 0.0, panel.width
        
        lines.append(f"CAERO5  {caero_id:<8}{pid:<8}{cp:<8}{nspan:<8}{nchord:<8}")
        lines.append(f"+       {x1:<8.4f}{y1:<8.4f}{z1:<8.4f}1.0     {x2:<8.4f}{y2:<8.4f}")
        lines.append(f"+       {x3:<8.4f}{y3:<8.4f}        1.0     {x4:<8.4f}{y4:<8.4f}")
        
        # PAERO5 property card
        lines.append(f"PAERO5  {pid:<8}")
        
        return lines
    
    def _generate_caero1(self, panel, nx: int, ny: int) -> List[str]:
        """Generate CAERO1 cards for Doublet Lattice Method"""
        lines = []
        caero_id = 1001
        
        lines.append("$ CAERO1 - Doublet Lattice Panels")
        
        # CAERO1 macro-element
        pid = 3001  # PAERO1 ID
        cp = 0      # Coordinate system
        nspan = ny  # Number of spanwise boxes
        nchord = nx # Number of chordwise boxes
        
        # Corner points with small Z offset for aerodynamic surface
        x1, y1, z1 = 0.0, 0.0, 0.001
        chord = panel.length
        
        lines.append(f"CAERO1  {caero_id:<8}{pid:<8}{cp:<8}{nspan:<8}{nchord:<8}        1       0")
        lines.append(f"+       {x1:<8.4f}{y1:<8.4f}{z1:<8.4f}{chord:<8.4f}")
        lines.append(f"+       {x1:<8.4f}{panel.width:<8.4f}{z1:<8.4f}{chord:<8.4f}")
        
        # PAERO1 property
        lines.append(f"PAERO1  {pid:<8}")
        
        return lines
    
    def _generate_splines(self, nx: int, ny: int) -> str:
        """Generate spline cards for structure-aerodynamic coupling"""
        lines = ["$ SPLINES - Structure to Aero Coupling"]
        
        spline_id = 1
        caero_id = 1001
        
        # Create SET1 card for structural nodes
        set_id = 1
        total_nodes = (nx + 1) * (ny + 1)
        
        lines.append(f"SET1    {set_id:<8}1       THRU    {total_nodes:<8}")
        
        # SPLINE1 card for surface spline
        lines.append(f"SPLINE1 {spline_id:<8}{caero_id:<8}        {set_id:<8}")
        
        return "\n".join(lines)
    
    def _generate_flutter_cards(self, flow, v_range: Tuple[float, float], n_modes: int) -> str:
        """Generate flutter analysis cards"""
        lines = ["$ FLUTTER ANALYSIS CARDS"]
        
        # FLUTTER card
        flutter_id = 1
        method = "PK"  # PK method for flutter
        density_id = 11
        mach_id = 12
        reduced_freq_id = 13
        
        lines.append(f"FLUTTER {flutter_id:<8}{method:<8}{density_id:<8}{mach_id:<8}{reduced_freq_id:<8}")
        lines.append(f"+               IMETH   EPS     NVALUE")
        lines.append(f"+               L       0.001   {n_modes:<8}")
        
        # FLFACT cards for parameters
        # Density ratios
        lines.append(f"FLFACT  {density_id:<8}1.0")
        
        # Mach numbers
        lines.append(f"FLFACT  {mach_id:<8}{flow.mach_number:<8.4f}")
        
        # Reduced frequencies (k = ωb/V)
        k_values = [0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 1.0]
        lines.append(f"FLFACT  {reduced_freq_id:<8}" + "".join([f"{k:<8.4f}" for k in k_values[:4]]))
        if len(k_values) > 4:
            lines.append(f"+       " + "".join([f"{k:<8.4f}" for k in k_values[4:8]]))
        
        return "\n".join(lines)
    
    def _generate_eigenvalue_cards(self, n_modes: int) -> str:
        """Generate eigenvalue extraction cards"""
        lines = ["$ EIGENVALUE EXTRACTION"]
        
        # EIGRL card for Lanczos method
        sid = 1
        v1 = 0.0      # Lower frequency bound
        v2 = 10000.0  # Upper frequency bound
        
        lines.append(f"EIGRL   {sid:<8}        {v1:<8.2f}{v2:<8.2f}{n_modes:<8}")
        
        return "\n".join(lines)
    
    def _format_sci(self, value: float) -> str:
        """Format scientific notation for NASTRAN"""
        return f"{value:.3E}".replace('E', '')[:8]
    
    def _validate_bdf(self, bdf_content: str) -> List[str]:
        """Validate BDF file for common errors"""
        errors = []
        lines = bdf_content.split('\n')
        
        # Check for required cards
        required_cards = ['SOL', 'CEND', 'MAT1', 'PSHELL', 'GRID', 'CQUAD4', 
                         'AERO', 'FLUTTER', 'EIGRL']
        
        for card in required_cards:
            if not any(card in line for line in lines):
                errors.append(f"Missing required card: {card}")
        
        # Check for duplicate IDs
        id_pattern = re.compile(r'^(GRID|CQUAD4|MAT1|PSHELL)\s+(\d+)')
        seen_ids = {}
        
        for line in lines:
            match = id_pattern.match(line)
            if match:
                card_type = match.group(1)
                card_id = match.group(2)
                key = f"{card_type}_{card_id}"
                
                if key in seen_ids:
                    errors.append(f"Duplicate ID: {card_type} {card_id}")
                seen_ids[key] = True
        
        return errors


class F06Parser:
    """
    Parses NASTRAN F06 output files to extract flutter results
    Handles both modal and flutter analysis outputs
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.modal_frequencies = []
        self.flutter_results = []
        self.errors = []
        self.warnings = []
    
    def parse(self, f06_path: Path) -> Dict[str, Any]:
        """
        Parse F06 file and extract results
        
        Args:
            f06_path: Path to F06 file
        
        Returns:
            Dictionary with parsed results
        """
        
        if not f06_path.exists():
            self.logger.error(f"F06 file not found: {f06_path}")
            return {'success': False, 'error': 'File not found'}
        
        try:
            with open(f06_path, 'r') as f:
                content = f.read()
            
            # Parse different sections
            self._parse_eigenvalues(content)
            self._parse_flutter_summary(content)
            self._parse_errors_warnings(content)
            
            # Find critical flutter point
            critical_speed, critical_freq = self._find_critical_flutter()
            
            return {
                'success': True,
                'modal_frequencies': self.modal_frequencies,
                'flutter_results': self.flutter_results,
                'critical_flutter_speed': critical_speed,
                'critical_flutter_frequency': critical_freq,
                'errors': self.errors,
                'warnings': self.warnings,
                'n_modes': len(self.modal_frequencies)
            }
            
        except Exception as e:
            self.logger.error(f"Failed to parse F06: {e}")
            return {'success': False, 'error': str(e)}
    
    def _parse_eigenvalues(self, content: str):
        """Extract modal frequencies from eigenvalue analysis"""
        
        # Pattern for eigenvalue table
        eigen_pattern = re.compile(
            r'R E A L\s+E I G E N V A L U E S.*?\n(.*?)(?:\n\n|\Z)',
            re.DOTALL | re.MULTILINE
        )
        
        match = eigen_pattern.search(content)
        if match:
            table_content = match.group(1)
            
            # Parse each row
            row_pattern = re.compile(
                r'^\s*(\d+)\s+([\d.E+-]+)\s+([\d.E+-]+)\s+([\d.E+-]+)',
                re.MULTILINE
            )
            
            for row_match in row_pattern.finditer(table_content):
                mode_num = int(row_match.group(1))
                eigenvalue = float(row_match.group(2))
                frequency_rad = float(row_match.group(3))  # rad/s
                frequency_hz = float(row_match.group(4))   # Hz
                
                self.modal_frequencies.append({
                    'mode': mode_num,
                    'eigenvalue': eigenvalue,
                    'frequency_hz': frequency_hz,
                    'frequency_rad': frequency_rad
                })
    
    def _parse_flutter_summary(self, content: str):
        """Extract flutter analysis results"""
        
        # Pattern for flutter summary table
        flutter_pattern = re.compile(
            r'FLUTTER SUMMARY.*?\n(.*?)(?:\n\n|\Z)',
            re.DOTALL | re.MULTILINE
        )
        
        match = flutter_pattern.search(content)
        if match:
            table_content = match.group(1)
            
            # Parse flutter points
            point_pattern = re.compile(
                r'^\s*(\d+)\s+([\d.E+-]+)\s+([\d.E+-]+)\s+([\d.E+-]+)\s+([\d.E+-]+)\s+([\d.E+-]+)',
                re.MULTILINE
            )
            
            for point_match in point_pattern.finditer(table_content):
                point = int(point_match.group(1))
                mach = float(point_match.group(2))
                velocity = float(point_match.group(3))
                damping = float(point_match.group(4))
                frequency = float(point_match.group(5))
                density_ratio = float(point_match.group(6))
                
                self.flutter_results.append({
                    'point': point,
                    'mach': mach,
                    'velocity': velocity,
                    'damping': damping,
                    'frequency': frequency,
                    'density_ratio': density_ratio
                })
    
    def _parse_errors_warnings(self, content: str):
        """Extract error and warning messages"""
        
        # Error patterns
        error_patterns = [
            r'\*\*\* USER FATAL MESSAGE.*?\n(.*?)(?:\n|\Z)',
            r'\*\*\* SYSTEM FATAL MESSAGE.*?\n(.*?)(?:\n|\Z)',
            r'\*\*\* ERROR.*?\n(.*?)(?:\n|\Z)'
        ]
        
        for pattern in error_patterns:
            for match in re.finditer(pattern, content, re.MULTILINE):
                self.errors.append(match.group(1).strip())
        
        # Warning patterns
        warning_patterns = [
            r'\*\*\* USER WARNING MESSAGE.*?\n(.*?)(?:\n|\Z)',
            r'\*\*\* SYSTEM WARNING MESSAGE.*?\n(.*?)(?:\n|\Z)',
            r'\*\*\* WARNING.*?\n(.*?)(?:\n|\Z)'
        ]
        
        for pattern in warning_patterns:
            for match in re.finditer(pattern, content, re.MULTILINE):
                self.warnings.append(match.group(1).strip())
    
    def _find_critical_flutter(self) -> Tuple[Optional[float], Optional[float]]:
        """Identify critical flutter point from V-g data"""
        
        if not self.flutter_results:
            return None, None
        
        # Sort by velocity
        sorted_results = sorted(self.flutter_results, key=lambda x: x['velocity'])
        
        # Find where damping crosses zero from negative to positive
        for i in range(len(sorted_results) - 1):
            d1 = sorted_results[i]['damping']
            d2 = sorted_results[i + 1]['damping']
            
            if d1 < 0 and d2 > 0:
                # Interpolate to find exact crossing point
                v1 = sorted_results[i]['velocity']
                v2 = sorted_results[i + 1]['velocity']
                f1 = sorted_results[i]['frequency']
                f2 = sorted_results[i + 1]['frequency']
                
                # Linear interpolation
                t = -d1 / (d2 - d1)
                v_critical = v1 + t * (v2 - v1)
                f_critical = f1 + t * (f2 - f1)
                
                return v_critical, f_critical
        
        # No flutter found (stable)
        return 9999.0, 0.0


def validate_nastran_interface():
    """Validate NASTRAN interface with test cases"""
    
    print("=" * 60)
    print("NASTRAN INTERFACE VALIDATION")
    print("=" * 60)
    
    # Test panel
    from flutter_analyzer import PanelProperties, FlowConditions
    
    panel = PanelProperties(
        length=0.3,
        width=0.3,
        thickness=0.0015,
        youngs_modulus=71.7e9,
        poissons_ratio=0.33,
        density=2810,
        boundary_conditions='SSSS'
    )
    
    flow = FlowConditions(
        mach_number=2.0,
        altitude=10000
    )
    
    # Test BDF generation
    print("\n1. BDF GENERATION TEST")
    print("-" * 40)
    
    generator = NastranBDFGenerator()
    bdf_content = generator.generate_flutter_bdf(
        panel, flow,
        mesh_nx=10, mesh_ny=10,
        n_modes=20,
        v_range=(100, 2000)
    )
    
    # Check BDF content
    required_cards = ['SOL 145', 'MAT1', 'PSHELL', 'GRID', 'CQUAD4', 
                     'AERO', 'FLUTTER', 'EIGRL', 'CAERO']
    
    for card in required_cards:
        if card in bdf_content:
            print(f"✓ {card} card present")
        else:
            print(f"✗ {card} card missing")
    
    # Count entities
    n_grids = bdf_content.count('GRID')
    n_elements = bdf_content.count('CQUAD4')
    print(f"\nMesh: {n_grids} nodes, {n_elements} elements")
    
    # Test F06 parsing (with mock data)
    print("\n2. F06 PARSING TEST")
    print("-" * 40)
    
    # Create mock F06 content
    mock_f06 = """
    R E A L   E I G E N V A L U E S
    MODE    EIGENVALUE      FREQUENCY       FREQUENCY
    NO.                      (RAD/SEC)        (HERTZ)
    1       1.234E+06       1.111E+03       1.769E+02
    2       4.567E+06       2.137E+03       3.402E+02
    3       8.901E+06       2.983E+03       4.748E+02
    
    FLUTTER SUMMARY
    POINT   MACH    VELOCITY    DAMPING     FREQUENCY   DENSITY
    1       2.0     500.0       -0.05       180.0       1.0
    2       2.0     800.0       -0.02       185.0       1.0  
    3       2.0     1000.0      0.01        190.0       1.0
    4       2.0     1200.0      0.04        195.0       1.0
    """
    
    # Save mock F06
    mock_path = Path("test_flutter.f06")
    with open(mock_path, 'w') as f:
        f.write(mock_f06)
    
    # Parse
    parser = F06Parser()
    results = parser.parse(mock_path)
    
    if results['success']:
        print(f"✓ Parsing successful")
        print(f"  Modal frequencies: {len(results['modal_frequencies'])} modes")
        print(f"  Flutter points: {len(results['flutter_results'])} points")
        print(f"  Critical speed: {results['critical_flutter_speed']:.1f} m/s")
        print(f"  Critical frequency: {results['critical_flutter_frequency']:.1f} Hz")
    else:
        print(f"✗ Parsing failed: {results.get('error')}")
    
    # Clean up
    mock_path.unlink()
    
    print("\n" + "=" * 60)
    print("VALIDATION COMPLETE")
    print("=" * 60)
    
    return True


if __name__ == "__main__":
    validate_nastran_interface()
